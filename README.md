# RCS Backend

[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=alert_status&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=security_rating&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Vulnerabilities](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=vulnerabilities&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=reliability_rating&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Maintainability Rating](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=sqale_rating&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Coverage](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=coverage&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Bugs](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=bugs&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=code_smells&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)
[![Technical Debt](https://sonarcloud.io/api/project_badges/measure?project=Pleno-Inc_pleno-rcs-backend&metric=sqale_index&token=b87aa352ba0ea47b78c3b914b3fcedf21975fa6d)](https://sonarcloud.io/summary/new_code?id=Pleno-Inc_pleno-rcs-backend)

Backend service for Raptor instrument control. Frontend/web clients request this service to schedule runs on the
instrument. This service would communicate with HAL to run the requested recipe and then launch primary and
secondary analysis while communicating current status to clients.

## Prerequisites

### Private NPM and Container repository access

To install npm packages from Pleno's private repo and pull the containers from the Pleno's private container registry
hosted on github, you'll need to have a Personal Access Token (Classic) configured.
See [Github Container Registry](https://plenoinc.atlassian.net/wiki/x/C4BdNQ) for more details.

### External services

You'll need to run a postgres server, HAL, and RASS. The quickest option is to spin them up with docker compose.
In order for the shared `/scratch` and `/scratchpc` folders to work properly, create `scratch` and `scratchpc`
folders in your root directory.
For MacOS, you'll need to create them in `/Users/Shared` and add the following file in the
`/etc` directory where the separator is a tab character and you'll need to reboot:

#### **`synthetic.conf`**

```text
scratch Users/Shared/scratch
scratchpc Users/Shared/scratchpc
```

Make sure all of the host directories that are getting mounted by `compose.yml` exist,
then spin up the services with the following command:

```bash
docker compose up --wait
```

NOTE: This will start two postgres servers: an instance for use with debugging on port 5432
and an instance for executing unit tests against on port 15432.

## Get started

```bash
git clone https://github.com/Pleno-Inc/pleno-rcs-backend.git
cd pleno-rcs-backend
npm i
```

## Pre-build prep

There are a few autogenerated files in this project that are produced in the npm `prep` script:

* src/common/version.ts - contains the version of the application
* src/schemas/* - contains json schema files and an index.ts file used for validating incoming payloads
* prisma client - contains types and functions for accessing the database

## Initialize/Migrate/Seed database

```bash
export RCS_DB_URL=postgresql://<user>:<password>@localhost:5432/rcs_db
npm run migrate-db
npm run seed-db
```

## Updating DB models

As the application evolves, the database models may need to change. To do this, make changes to
`./prisma/schema.prisma` and then generate a new migration by running `npm run add-migration <migration-name>`.
This will generate a new migration in `./prisma/migrations`. To apply it to your databases,
run `npm run migrate-db` and `npm run migrate-db:test`.

## Adding new seed data

To add new seed data, add a new file or update an existing file in `./prisma/seeds` and run `npm run seed-db`.

## Updating Prisma client

If changes have been made to the schema but no migrations have been created, you may need to regenerate the
Prisma client by running `npm run generatePrismaClient` (which also is run via `npm run prep`).

## Run application

```bash
npm run prep
npm start
```

## Run tests

```bash
npm run prep
npm test
```

## Project layout

The application is structured in layers with well defined separation of concerns.

* `common` - a collection of utility functions which have no external resource dependencies that
can be used by other components
* `enums` and `@types` - models that are used for data transfer or interfaces that are not represented
as a model in the database
* `schemas` - JSON schemas that are generated from `@types` with `npm run prep` that are used to validate
request body payloads sent from a client
* `repositories` - per-table repository functions which typically contain CRUD operations
but can also contain critical business logic
* `adapters` - business logic functions that interface with outside resources such as HAL and RASS
* `controllers` - business logic functions that use the `repository` and `adapter` functions
* `middleware` - common middleware functions that are executed when `routes` are accessed
* `routes` - logical groupings of REST endpoints which use the `controller` functions

## Launch configuration for debugging in VSCode

```json
{
  "name": "Debug RCS",
  "type": "node",
  "runtimeVersion": "22.15.0",
  "runtimeExecutable": "tsx",
  "request": "launch",
  "cwd": "${workspaceFolder:rcs}",
  "program": "${workspaceFolder:rcs}/src/index.ts",
  "outputCapture": "std",
  "sourceMaps": true
}
```

## Running the docker image

### migrate/seed the database

If a container is already running, you can run this:

```bash
docker exec $RCS_CONTAINER_NAME bash -c "INIT_DB=true ./docker-entry-point.sh"
```

If a container is not yet running, you can run this:

```bash
docker run --rm --init --name rcs --network=host \
  -v /local/path/to/logs:/app/logs \
  -v /local/path/to/jobs:/app/jobs \
  -e INIT_DB=true \
  ghcr.io/pleno-inc/pleno-rcs-backend:$RCS_VERSION
```

### deploy and run on an instrument

First, obtain the files you need for the desired version of RCS:

* from the pleno-rcs-backend [Build Distribution](https://github.com/Pleno-Inc/pleno-rcs-backend/actions/workflows/build_dist.yml) action on github
  * click the `Run workflow` button to trigger a build
  * in the resulting dialog select the branch you wish to build or enter the RCS image version tag you wish to use and click `Run Workflow`
  * once the workflow has completed, download the `rcs-backend-dist-*` file from the Artifacts section in the workflow summary
  * unzip the `rcs-backend-dist-*` file into a folder
  * copy the contents of that folder to `/opt/pleno/pleno-rcs-backend` on the instrument (Make sure you include the `.env` file!)
* alternatively, from this repo, build a local distribution (note that you need to build the docker image for the correct architecture, amd64)
  * build a distribution from local by running `./build-dist.sh` or from the docker repo by running
  `.build-dist.sh {rcs-version}`, where `{rcs-version}` is the image tag
  * copy the contents of `./dist` in this repo to `/opt/pleno/pleno-rcs-backend` on the instrument (Make sure you include the `.env` file!)

Next, on the instrument:

* run `cd /opt/pleno/pleno-rcs-backend`
* make sure the scripts are executable by running `chmod 755 *.sh`
* update the `INSTRUMENT_NAME` value in the `.env` file
* if docker isn't installed, run `./install_docker.sh`
* if RCS is already running, run `./stop_rcs.sh` (you can check with `docker ps`)
* run `./start_rcs.sh`

### run RCS service in docker locally

```bash
docker run --rm --init --name rcs --network=host \
  -v /local/path/to/logs:/app/logs \
  -v /local/path/to/jobs:/app/jobs \
  ghcr.io/pleno-inc/pleno-rcs-backend:$RCS_VERSION
```

You can override the configuration by passing in values for the following environment variables:

* HAL_HOST (default: `localhost`)
* HAL_API_PORT (default: `5002`)
* HAL_EVENT_PORT (default: `5002`)
* RASS_HOST (default: `localhost`)
* RASS_REST_PORT (default: `50055`)
* RCS_DB_URL (default: `postgresql://postgres:postgres@localhost:5432/rcs_db`)
* RCS_SERVER_HOST (default: `localhost`)
* RCS_SERVER_PORT (default: `1265`)
* RCS_JWT_ENCRYPTION_KEY (default: `a_pleno_secret_key`, definitely should override this one)
* RCS_JWT_ISSUER (default: `RCS`)
* RCS_JWT_AUDIENCE (default: `RCS`)
* RCS_DEBUG_SOCKET_IO (default: `false`)
* RCS_LOG_DIR (default: `./logs`)
* RCS_SERVER_LOG_LEVEL (default: `info`)
* RCS_JOBS_DATA_ROOT_PATH (default: `/scratch`)
* RCS_JOBS_ANALYSIS_ROOT_PATH (default: `/scratchpc`)
* INSTRUMENT_NAME (default: `KET-LOCAL`)
* RCS_DEMO_MODE (default: `false`)
* RCS_FLOW_COUNT_OVERRIDE (default: ``)
* RCS_RASS_REQUIRED (default: `false`)

NOTE: Because `RCS_JOBS_DATA_ROOT_PATH` needs to be accessible by HAL, RCS, and RASS, the mount into the
RCS container needs to match the host path, i.e. `-v /path/to/jobs:/path/to/jobs`.
